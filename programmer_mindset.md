Most programmers start coding with a feeling like this: a fog of ambiguity, wondering if their solution will work, exploring the way forward the best that they can. But programmers have a process to give them the confidence that, if they follow it, the fog will disappear, the solution will become clear and they'll reach their intended destination.

This process doesn't have anything to do with code. Instead, it relies on the way we think about and approach problems. We can adjust our own mindset away from the idea that programmers always know immediately what to code and towards the idea that programmers actually just know how to concentrate, test theories and develop a practice of problem solving.

The Programmer's Mindset
Mindfulness
Mindfulness in programming, as with everything worth doing in life, is the key. It just happens that we're going to build that supporting skill by doing programming. Most of the anti-patterns we discuss have lack-of-mindfulness at their root: coding while texting, pairing while browsing Instagram, copying random-dude420's solution from Stack Overflow. You're doing right when you're doing work. When it's hard, when you'd rather do something mindless like social media, you're doing the right thing. Don't stop. Be mindful.

Bravery
Solving problems that no one has completed before, or that have stymied the most brilliant humans ever to walk this earth is daunting. Who are you, who am I, who are we to dare such things?

The human kind.

The kind that descended the trees, harnessed fire, built civilizations in river valleys and put our footprint on the Moon. All of these were hard problems that all the geniuses and sages before couldn't solve, until someone dared to try. Embrace uncertainty, but also embrace your inner warrior. You are in a battle against your own unknowing. You can win.

Focus
We mentioned it under another name as "mindfulness" but while "mindfulness" recalls yoga poses and self-help books, it has a practical side we call "focus." When you feel the distraction machines (phones, notification pings, a morbid curiosity about whatever happened to nobody you really care about on some reality show that society would be better off without) clawing at your attention, realize that they are multi-billion dollar industries that profit from keeping your attention like an addict and selling it off by the half-hour.

The only thing keeping you from this fate is your will â€” which they launch focused campaigns to weaken.

In general, the idea is "don't get up until it's done." Now obviously this can be a bad thing, sometimes you need food, sometimes a 10 minute walk will help you think of a solution you might not have seen previously. But in general, when you hit a bug, when you hit a problem, don't get up from the computer. Stick with the problem until it's done. Don't "lose" your game face.

Another practice that will help you here is, before you start building, to break down each component of the solution into a "deliverable." Make promises to yourself that you'll go to dinner, you'll make that phone call, you'll waste 15 minutes on social media once that deliverable is working, tested, clean, and saved.

Don't Flail
Work from a problem solving process. Don't randomly add code and hope that this next run will somehow magically get the answer. Make sure that each time you run the code that you expect it to output some validation of your direction toward the answer or the answer itself.

Don't Curate the Internet's Solutions
Many of the challenges we give at FIS are standard problems that require very little external pre-existing knowledge. As a result most programming languages have built-in or readily copy-and-pasteable solutions. But this is not programming. Learn from the solutions, see the part you're missing, update your process. But if you simply use someone else's solution but don't enrich your mental models you've made the poorest investment possible.

Respect the Problem
Lastly, and perhaps the most important, guideline: respect the problem. Sometimes the problem seems simple, but when you dig into it's really more complicated. Be honest with yourself, and peers, bosses and collaborators and own up to having misjudged the size of the problem.

Sometimes the problem's interconnected to other parts of the system in surprising ways. Sometimes there's a hidden snarl of complex code you didn't expect to find. Perhaps the code depends on mathematics or business knowledge you don't have that you need to learn more about.

Whatever the case, sometimes problems are hard and fool us. It's far better to admit this and follow your process than to provide a fix while choosing to be blind to complexity. That's how you get garbage solutions that ultimately create more problems than progress.

Conclusion
Think of each one of these steps as a practice. Maybe you could copy/paste them into a document and work on one each day until it's internalized. Once you operate from a programmer's mindset on a continuous basis, you'll notice that your results consistently, dramatically improve.